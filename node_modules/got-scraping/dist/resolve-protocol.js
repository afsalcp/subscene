"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createResolveProtocol = void 0;
const tslib_1 = require("tslib");
const net_1 = require("net");
const tls_1 = tslib_1.__importDefault(require("tls"));
const url_1 = require("url");
const http2_wrapper_1 = require("http2-wrapper");
const quick_lru_1 = tslib_1.__importDefault(require("quick-lru"));
const connect = async (proxyUrl, options, callback) => new Promise((resolve, reject) => {
    let host = `${options.host}:${options.port}`;
    if ((0, net_1.isIPv6)(options.host)) {
        host = `[${options.host}]:${options.port}`;
    }
    (async () => {
        try {
            const headers = {
                host,
            };
            const url = new url_1.URL(proxyUrl);
            const username = decodeURIComponent(url.username);
            const password = decodeURIComponent(url.password);
            if (username || password) {
                headers.authorization = `Basic ${Buffer.from(`${username}:${password}`).toString('base64')}`;
                headers['proxy-authorization'] = headers.authorization;
            }
            const request = await (0, http2_wrapper_1.auto)(url, {
                method: 'CONNECT',
                headers,
                path: host,
                rejectUnauthorized: false,
            });
            request.end();
            request.once('error', reject);
            request.once('connect', (response, socket, head) => {
                if (response.statusCode !== 200 || head.length > 0) {
                    reject(new Error(`Proxy responded with ${response.statusCode}: ${head.length} bytes`));
                    socket.destroy();
                    return;
                }
                const tlsSocket = tls_1.default.connect({
                    ...options,
                    socket,
                }, callback);
                resolve(tlsSocket);
            });
        }
        catch (error) {
            reject(error);
        }
    })();
});
const createCaches = () => ({
    protocolCache: new quick_lru_1.default({ maxSize: 1000 }),
    resolveAlpnQueue: new Map(),
});
const defaults = createCaches();
const createResolveProtocol = (proxyUrl, sessionData) => {
    let { protocolCache, resolveAlpnQueue } = defaults;
    if (sessionData) {
        if (!sessionData.protocolCache || !sessionData.resolveAlpnQueue) {
            Object.assign(sessionData, createCaches());
        }
        protocolCache = sessionData.protocolCache;
        resolveAlpnQueue = sessionData.resolveAlpnQueue;
    }
    const connectWithProxy = async (pOptions, pCallback) => {
        return connect(proxyUrl, pOptions, pCallback);
    };
    return http2_wrapper_1.auto.createResolveProtocol(protocolCache, resolveAlpnQueue, connectWithProxy);
};
exports.createResolveProtocol = createResolveProtocol;
//# sourceMappingURL=resolve-protocol.js.map