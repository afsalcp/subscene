"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fixDecompress = void 0;
const tslib_1 = require("tslib");
const zlib_1 = tslib_1.__importDefault(require("zlib"));
const stream_1 = require("stream");
const mimic_response_1 = tslib_1.__importDefault(require("mimic-response"));
const onResponse = (response, propagate) => {
    var _a;
    const encoding = (_a = response.headers['content-encoding']) === null || _a === void 0 ? void 0 : _a.toLowerCase();
    // Append empty chunk.
    const zlibOptions = {
        flush: zlib_1.default.constants.Z_SYNC_FLUSH,
        finishFlush: zlib_1.default.constants.Z_SYNC_FLUSH,
    };
    const useDecompressor = (decompressor) => {
        delete response.headers['content-encoding'];
        const result = new stream_1.PassThrough({
            autoDestroy: false,
            destroy(error, callback) {
                response.destroy();
                callback(error);
            },
        });
        decompressor.once('error', (error) => {
            result.destroy(error);
        });
        response.pipe(decompressor).pipe(result);
        propagate((0, mimic_response_1.default)(response, result));
    };
    if (encoding === 'gzip' || encoding === 'x-gzip') {
        useDecompressor(zlib_1.default.createGunzip(zlibOptions));
    }
    else if (encoding === 'deflate' || encoding === 'x-deflate') {
        let read = false;
        response.once('data', (chunk) => {
            read = true;
            response.unshift(chunk);
            // See http://stackoverflow.com/questions/37519828
            // eslint-disable-next-line no-bitwise
            const decompressor = (chunk[0] & 0x0F) === 0x08 ? zlib_1.default.createInflate() : zlib_1.default.createInflateRaw();
            useDecompressor(decompressor);
        });
        response.once('end', () => {
            if (!read) {
                propagate(response);
            }
        });
    }
    else if (encoding === 'br') {
        useDecompressor(zlib_1.default.createBrotliDecompress());
    }
    else {
        propagate(response);
    }
};
// Some websites incorrectly compress the response.
// Got is very strict so it would throw.
// Browsers don't, so we need fix this.
const fixDecompress = (options, next) => {
    const result = next(options);
    // @ts-expect-error Looks like a TypeScript bug
    result.on('request', (request) => {
        const emit = request.emit.bind(request);
        request.emit = (event, ...args) => {
            // It won't double decompress, because Got checks the content-encoding header.
            // We delete it if the response is compressed.
            if (event === 'response' && options.decompress) {
                const response = args[0];
                const emitted = request.listenerCount('response') !== 0;
                onResponse(response, (fixedResponse) => {
                    emit('response', fixedResponse);
                });
                return emitted;
            }
            return emit(event, ...args);
        };
    });
    return result;
};
exports.fixDecompress = fixDecompress;
//# sourceMappingURL=fix-decompress.js.map