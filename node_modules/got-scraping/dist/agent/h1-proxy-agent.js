"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpsProxyAgent = exports.HttpProxyAgent = exports.HttpRegularProxyAgent = void 0;
const tslib_1 = require("tslib");
/* eslint-disable max-classes-per-file */
const url_1 = require("url");
const net_1 = require("net");
const tls_1 = tslib_1.__importDefault(require("tls"));
const http_1 = tslib_1.__importDefault(require("http"));
const https_1 = tslib_1.__importDefault(require("https"));
const initialize = (self, options) => {
    self.proxy = typeof options.proxy === 'string' ? new url_1.URL(options.proxy) : options.proxy;
};
const getBasic = (url) => {
    let basic = '';
    if (url.username || url.password) {
        const username = decodeURIComponent(url.username);
        const password = decodeURIComponent(url.password);
        basic = Buffer.from(`${username}:${password}`).toString('base64');
        return `Basic ${basic}`;
    }
    return basic;
};
class HttpRegularProxyAgent extends http_1.default.Agent {
    constructor(options) {
        super(options);
        Object.defineProperty(this, "proxy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        initialize(this, options);
    }
    addRequest(request, options) {
        if (options.socketPath) {
            // @ts-expect-error @types/node is missing types
            super.addRequest(request, options);
            return;
        }
        let hostport = `${options.host}:${options.port}`;
        if ((0, net_1.isIPv6)(options.host)) {
            hostport = `[${options.host}]:${options.port}`;
        }
        const url = new url_1.URL(`${request.protocol}//${hostport}${request.path}`);
        options = {
            ...options,
            host: this.proxy.hostname,
            port: this.proxy.port,
        };
        request.path = url.href;
        const basic = getBasic(this.proxy);
        if (basic) {
            request.setHeader('proxy-authorization', basic);
        }
        // @ts-expect-error @types/node is missing types
        super.addRequest(request, options);
    }
}
exports.HttpRegularProxyAgent = HttpRegularProxyAgent;
class HttpProxyAgent extends http_1.default.Agent {
    constructor(options) {
        super(options);
        Object.defineProperty(this, "proxy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        initialize(this, options);
    }
    createConnection(options, callback) {
        if (options.path) {
            // @ts-expect-error @types/node is missing types
            super.createConnection(options, callback);
            return;
        }
        const fn = this.proxy.protocol === 'https:' ? https_1.default.request : http_1.default.request;
        let hostport = `${options.host}:${options.port}`;
        if ((0, net_1.isIPv6)(options.host)) {
            hostport = `[${options.host}]:${options.port}`;
        }
        const headers = {
            host: hostport,
        };
        const basic = getBasic(this.proxy);
        if (basic) {
            headers['proxy-authorization'] = basic;
            headers.authorization = basic;
        }
        const connectRequest = fn(this.proxy, {
            method: 'CONNECT',
            headers,
            path: hostport,
            agent: false,
            rejectUnauthorized: false,
        });
        connectRequest.once('connect', (response, socket, head) => {
            if (head.length > 0 || response.statusCode !== 200) {
                socket.destroy();
                const error = new Error(`The proxy responded with ${response.statusCode}: ${head.toString()}`);
                callback(error);
                return;
            }
            if (options.protocol === 'https:') {
                callback(undefined, tls_1.default.connect({
                    ...options,
                    socket,
                }));
                return;
            }
            callback(undefined, socket);
        });
        connectRequest.once('error', (error) => {
            callback(error);
        });
        connectRequest.end();
    }
}
exports.HttpProxyAgent = HttpProxyAgent;
class HttpsProxyAgent extends https_1.default.Agent {
    constructor(options) {
        super(options);
        Object.defineProperty(this, "proxy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        initialize(this, options);
    }
    createConnection(options, callback) {
        HttpProxyAgent.prototype.createConnection.call(this, options, callback);
    }
}
exports.HttpsProxyAgent = HttpsProxyAgent;
//# sourceMappingURL=h1-proxy-agent.js.map